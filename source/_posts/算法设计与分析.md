---
title: 算法设计与分析
date: 2018-09-11 17:28:59
updated: 2018-09-11 17:28:59
tags: [算法, algorithm]
categories: algorithm
---

# 第一章 概述

## 算法学习的重要性
&nbsp;&nbsp;主要内容：
* 递归/分治
* 动态规划
* 贪心算法
* 回溯算法
* 分枝限界
* 高级数据结构
* 复杂度理论
* 随机算法
* 近似算法
* 并行算法


## 算法的特性
* 有输入
* 有输出
* 确定性
* 有限性

## 复杂性分析

### 暴力求解方法
&nbsp;&nbsp;Brute：force；暴风，强力；布鲁特-福斯
&nbsp;&nbsp;常用思路：
1. 遍历解空间
2. 答案表

### 时间复杂性/空间复杂性

$C = F(N,I,A)$

&nbsp;&nbsp;主要考虑以下两个方面：
1. 问题的规模
2. 具体的输入

### 最优、最差、平均运行时间

- worst-case:
  $$Tmax(N) = max(I∈D) T(N,I)$$
- best-case Tmin(N) = min(I∈D) T(N,I)
- average-case Tavg(N) = Σ(I∈D) P(I) T(N,I)


### 渐近符号
1. **O 的定义**：若存在正常数 C 和自然数 N。使得当 N≥N0 时有 f(N) 小于等于 C * g(N)则称函数 f(N) 当 N 充分大时， g(N) 是它的一个上界，即 f(N) 的阶不高于 g(N)。

2. **Ω的定义**：若存在正常数 C 和自然数 N。使得当 N≥N0 时有 f(N) ≥ C * g(N) 则称函数 f(N) 当 N 充分大时， g(N) 是它的一个下界，即 f(N) 的阶不低于 g(N)。

3. **θ的定义**：定义 f(N) = θ(g(n)) 当且仅当 f(N) = O(g(n)) 且 f(N) = Ω(g(N)) 即 f(N) 与 g(N) 同阶。

4.
    ```
    O(f) + O(g) = O(max( f * g))
    O(f) + O(g) = O(f + g)
    O(f) * O(g) = O(f * g)
    若 g(N) = O(f(N))，则 O(f) + O(g) = O(θ)
    ```
5. 基本效率类型

| 搜索 | 遍历 | 排序 | 2重循环 | 3重循环 | 求 n 个元素子集 | 求全排列 |
| :------: | :------: | :------: | :------: | :------: | :------: | :------: |
| log2 n | n | n * log2 n | n^2 | n^3 | 2^n | n! |
| 3.3 | 10 | 3.3 | 10^2 | 10^3 | 10^3 | 3.6 * 10^6 |
| 6.6 | 100 | 6.6 * 10 | 10^4 | 10^6 | 1.3 * 10^30 | 9.3 * 10^157 |
| 10 | 10^3 | 1.0 * 10^4 | 10^6 | 10^9 |  |  |
| 13 | 10^4 | 1.3 * 10^5 | 10^8 | 10^12 |  |  |
| 17 | 10^5 | 1.7 * 10^6 | 10^10 | 10^15 |  |  |
| 20 | 10^6 | 2.0 * 10^7 | 10^12 | 10^18 |  |  |

### NP 完全性理论
1. 可能的下界
    1. 平凡下界
    2. 信息论下界
2.  NP完全性理论
    - P: 在确定计算模型下，多项式时间可解。
    - NP: 在非确定计算模型下：
        1. 猜一个解。
        2. 验证上面的解，在多项式时间完成。
    - NP-C: D 是 NPC，在 NP 问题集合中的任何一个问题都能够在多项式时间内被转化成 D。
    - 例子：
        1. 哈密顿回路
        2. 旅行商问题
        3. 背包问题
        4. 划分问题
        5. 装箱问题
        6. 图着色问题

# 第二章 递归与分治

## 递归

### 定义
&nbsp;&nbsp;直接或间接调用自身的算法
- 优点 编码便利
- 缺点 展开的代价巨大

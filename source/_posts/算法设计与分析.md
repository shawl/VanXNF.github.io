---
title: 算法设计与分析
date: 2018-09-11 17:28:59
updated: 2018-09-11 19:07:34
tags: [算法, algorithm]
categories: Algorithm
---

# 第一章 概述

## 算法学习的重要性
&nbsp;&nbsp;主要内容：
* 递归/分治
* 动态规划
* 贪心算法
* 回溯算法
* 分枝限界
* 高级数据结构
* 复杂度理论
* 随机算法
* 近似算法
* 并行算法


## 算法的特性
* 有输入：有外部提供的量作为算法的输入。
* 有输出：算法产生至少一个量作为输出。
* 确定性：组成算法的每条指令都是清晰的，无歧义的。
* 有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。


## 复杂性分析
&nbsp;&nbsp;算法复杂性即算法所需要的计算机资源。

### 暴力求解方法
&nbsp;&nbsp;Brute：force；暴风，强力；布鲁特-福斯

&nbsp;&nbsp;常用思路：
1. 遍历解空间
2. 答案表
   - 可排序
   - 不可排序

### 时间复杂性/空间复杂性

$C = F(N,I,A)$

&nbsp;&nbsp;N 是问题的规模，I 是具体输入。

&nbsp;&nbsp;主要考虑以下两个方面：
1. 问题的规模
2. 具体的输入

### 最优、最差、平均运行时间

- worst-case:

  $$T_{max}(N) = {_{I\in D}^{max}}\ T(N,I)$$
- best-case

  $$T_{min}(N) = \  {_{I\in D}^{min}}\ T(N,I)$$
- average-case

  $$T_{avg}(N) = \sum_{I\in D}\ P(I) T(N,I)$$



### 渐近符号
1. **$O$ 的定义**：若存在正常数 C 和自然数 N。使得当 $N\geq N_0$ 时有 $f(N)\leq C\cdot g(N)$ 则称函数 $f(N)$ 当 N 充分大时， $g(N)$ 是它的一个上界，即 $f(N)$ 的阶不高于 $g(N)$。

2. **$\Omega$ 的定义**：若存在正常数 C 和自然数 N。使得当 $N\geq N_0$ 时有 $f(N)\geq C\cdot g(N)$ 则称函数 $f(N)$ 当 N 充分大时， $g(N)$ 是它的一个下界，即 $f(N)$ 的阶不低于 $g(N)$。

3. **$\theta$ 的定义**：定义 $f(N) = \theta(g(n))$ 当且仅当 $f(N) = O(g(n))$ 且 $f(N) = \Omega (g(N))$ 即 $f(N)$ 与 $g(N)$ 同阶。

4. $O(f) + O(g) = O(max( f \cdot g))$

   $O(f) + O(g) = O(f + g)$

   $O(f) * O(g) = O(f \cdot g)$

   $若 g(N) = O(f(N))，则 O(f) + O(g) = O(\theta )$

5. 基本效率类型

| 搜索 | 遍历 | 排序 | 2重循环 | 3重循环 | 求 n 个元素子集 | 求全排列 |
| :------: | :------: | :------: | :------: | :------: | :------: | :------: |
| $log_2n$ | n | $n\cdot log_2n$ | $n^2$ | $n^3$ | $2^n$ | $n!$ |
| 3.3 | 10 | 3.3 | $10^2$ | $10^3$ | $10^3$ | $3.6\cdot 10^6$ |
| 6.6 | 100 | $6.6 \times 10$ | $10^4$ | $10^6$ | $1.3 \times 10^{30}$ | $9.3 \times 10^{157}$ |
| 10 | $10^3$ | $1.0 \times 10^4$ | $10^6$ | $10^9$ |  |  |
| 13 | $10^4$ | $1.3 \times 10^5$ | $10^8$ | $10^{12}$ |  |  |
| 17 | $10^5$ | $1.7 \times 10^6$ | $10^{10}$ | $10^{15}$ |  |  |
| 20 | $10^6$ | $2.0 \times 10^7$ | $10^{12}$ | $10^{18}$ |  |  |

### NP 完全性理论
1. 可能的下界
    1. 平凡下界
    2. 信息论下界
2.  NP完全性理论
    - P: 在确定计算模型下，多项式时间可解。
    - NP: 在非确定计算模型下：
        1. 猜一个解。
        2. 验证上面的解，在多项式时间完成。
    - NP-C: D 是 NPC，在 NP 问题集合中的任何一个问题都能够在多项式时间内被转化成 D。
    - 例子：
        1. 哈密顿回路
        2. 旅行商问题
        3. 背包问题
        4. 划分问题
        5. 装箱问题
        6. 图着色问题

# 第二章 递归与分治

## 递归

### 定义
&nbsp;&nbsp;直接或间接调用自身的算法
- 优点 编码便利
- 缺点 展开的代价巨大

# 未完待续
